import 'dotenv/config';
import { ChatOpenAI } from '@langchain/openai';
import { DynamicTool } from '@langchain/core/tools';
import { ChatPromptTemplate, MessagesPlaceholder } from '@langchain/core/prompts';
import { convertToOpenAIFunction } from '@langchain/core/utils/function_calling';
import { RunnableSequence } from '@langchain/core/runnables';
import { AgentExecutor } from 'langchain/agents';
import { formatToOpenAIFunctionMessages } from 'langchain/agents/format_scratchpad';
import { OpenAIFunctionsAgentOutputParser } from 'langchain/agents/openai/output_parser';
import { AIMessage, HumanMessage } from '@langchain/core/messages';
import { z } from 'zod';
import { MongoClient } from 'mongodb';

// database connection setup
const uri = process.env.MONGODB_URI;

let client;
let db;

/* 
 * function to connect to the MongoDB database
 * @returns {Promise<Object>} - the MongoDB database instance
 */
async function connect_to_database() {
  if (!client || !client.isConnected()) {
    client = new MongoClient(uri, { useNewUrlParser: true, useUnifiedTopology: true });
    await client.connect();
    db = client.db('your_database_name'); // NEED TO REPLACE
  }
  return db;
}

const openai_api_key = process.env.OPENAI_API_KEY;

const model = new ChatOpenAI({
  model: 'gpt-4o',
  temperature: 0,
  apiKey: openai_api_key,
});

// minimal schema for placeholder tool
const placeholder_schema = z.object({
  meal: z.string(),
});

// placeholder tool to avoid empty functions array error
const placeholder_tool = new DynamicTool({
  name: 'placeholder_tool',
  description: 'This is a placeholder tool.',
  func: async () => {
    return 'This is a placeholder response.';
  },
  schema: placeholder_schema,
});

const tools = [placeholder_tool];

// get the current time and day
const current_date_time = new Date();
const current_time = current_date_time.toTimeString().split(' ')[0];
const current_day = current_date_time.toLocaleDateString('en-US', { weekday: 'long' });

// warmup prompt
const prompt = ChatPromptTemplate.fromMessages([
  ['system', `You are a helpful assistant for an app called Nom. Your role is to generate or modify meal plans for the user. By default, meal plans contain 3 meals a day for a week. When creating a meal plan, start it at the next upcoming meal based on the current time and day. You must produce a full meal plan without leaving out any meals. The current time is ${current_time} and the current day is ${current_day}. Your output must be formed like [response that will be displayed separately] [json]. You must output the meal plan just once in the following JSON format without any newlines or extra whitespace: {{"days":[{{"day":1,"meals":{{"breakfast":"","lunch":"","dinner":""}}}}, ... ]}}.`],
  ['user', '{input}'],
  new MessagesPlaceholder('agent_scratchpad'),
]);

// langchain agent tools
const model_with_functions = model.bind({
  functions: tools.map(tool => convertToOpenAIFunction(tool)),
});

// create langchain agent
const runnable_agent = RunnableSequence.from([
  {
    input: (i) => i.input,
    agent_scratchpad: (i) => formatToOpenAIFunctionMessages(i.steps),
  },
  prompt,
  model_with_functions,
  new OpenAIFunctionsAgentOutputParser(),
]);

const executor = AgentExecutor.fromAgentAndTools({
  agent: runnable_agent,
  tools,
});

/* 
 * function to call the agent
 * @param {string} input - the user input to be processed by the agent
 * @param {number} retries - the number of retry attempts
 * @returns {Promise<Object>} - the final meal plan generated by the agent
 */
async function call_agent(input, retries = 3) {
  console.log(`Calling agent executor with query: ${input}`);
  let attempt = 0;
  while (attempt < retries) {
    try {
      const result = await executor.invoke({ input });
      console.log('Raw Output:', result);

      const meal_plan = await parse_and_verify_output(result.output);
      if (meal_plan) {
        console.log('Final Meal Plan:', meal_plan);
        return meal_plan;
      }
    } catch (error) {
      console.error(`Error on attempt ${attempt + 1}:`, error);
    }
    attempt++;
  }
  console.error('Failed to generate a valid meal plan after multiple attempts.');
  return null;
}

/* 
 * function to parse and verify the output
 * @param {string} output - the raw output from the agent
 * @returns {Promise<Object|null>} - the parsed and verified meal plan or null if an error occurs
 */
async function parse_and_verify_output(output) {
  try {
    // extract the response part from the brackets
    const response_match = output.match(/\[(.*?)\]/);
    const response = response_match ? response_match[1].trim() : null;

    // extract the JSON part of the response
    const json_match = output.match(/{[\s\S]*}/);
    if (!json_match) {
      throw new Error('No JSON found in the output');
    }
    const json_string = json_match[0];
    const meal_plan = JSON.parse(json_string);

    return { meal_plan, response };
  } catch (error) {
    console.error('Error parsing or verifying the meal plan:', error);
    throw new Error('No JSON found in the output');
  }
}

/* 
 * function to get user preferences from MongoDB
 * @param {string} userId - the user ID to fetch preferences for
 * @returns {Promise<Object>} - the user preferences from the database
 */
async function get_user_preferences(userId) {
  try {
    const db = await connect_to_database();
    const preferences = await db.collection('user_preferences').findOne({ userId });
    return preferences || {};
  } catch (error) {
    console.error('Error connecting to the database or fetching preferences:', error);
    return {};
  }
}

// current example
const user_input = "I want to bake a creme brulee recipe one night, and I want at least one Italian recipe.";
const user_id = "user123"; // replace with actual user ID

(async () => {
  const preferences = await get_user_preferences(user_id);
  const full_input = `${user_input}\nUser Preferences: ${JSON.stringify(preferences)}`;
  const result = await call_agent(full_input);
  console.log('Parsed and Verified Meal Plan:', result);
})();

// memory for stateful conversation
const MEMORY_KEY = 'chat_history';
const chat_history = [];

const memory_prompt = ChatPromptTemplate.fromMessages([
  ['system', 'You are a helpful assistant for an app called Nom. Your role is to generate or modify meal plans for the user. By default, meal plans contain 3 meals a day for a week. When creating a meal plan, start it at the next upcoming meal based on the time and day you receive the request.'],
  new MessagesPlaceholder(MEMORY_KEY),
  ['user', '{input}'],
  new MessagesPlaceholder('agent_scratchpad'),
]);

const agent_with_memory = RunnableSequence.from([
  {
    input: (i) => i.input,
    agent_scratchpad: (i) => formatToOpenAIFunctionMessages(i.steps),
    chat_history: (i) => i.chat_history,
  },
  memory_prompt,
  model_with_functions,
  new OpenAIFunctionsAgentOutputParser(),
]);

const executor_with_memory = AgentExecutor.fromAgentAndTools({
  agent: agent_with_memory,
  tools,
});

/* 
 * function to call the agent with memory
 * @param {string} input - the user input to be processed by the agent
 * @returns {Promise<string>} - the final output from the agent
 */
async function call_agent_with_memory(input) {
  console.log(`Calling agent executor with query: ${input}`);
  const result = await executor_with_memory.invoke({ input, chat_history });
  console.log(result);

  chat_history.push(new HumanMessage(input));
  chat_history.push(new AIMessage(result.output));

  return result.output;
}

// example code of how to do followup input
// const user_input_with_memory = "How many letters in the word educa?";
// call_agent_with_memory(user_input_with_memory).then(result => {
//   console.log('Final Result:', result);

//   const follow_up_input = "Is that a real English word?";
//   return call_agent_with_memory(follow_up_input);
// }).then(result => {
//   console.log('Follow-Up Result:', result);
// }).catch(error => {
//   console.error('Error:', error);
// });