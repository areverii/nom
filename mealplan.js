import 'dotenv/config';
import { ChatOpenAI } from '@langchain/openai';
import { DynamicTool } from '@langchain/core/tools';
import { ChatPromptTemplate, MessagesPlaceholder } from '@langchain/core/prompts';
import { convertToOpenAIFunction } from '@langchain/core/utils/function_calling';
import { RunnableSequence } from '@langchain/core/runnables';
import { AgentExecutor } from 'langchain/agents';
import { formatToOpenAIFunctionMessages } from 'langchain/agents/format_scratchpad';
import { OpenAIFunctionsAgentOutputParser } from 'langchain/agents/openai/output_parser';
import { AIMessage, HumanMessage } from '@langchain/core/messages';
import { z } from 'zod';

const openai_api_key = process.env.OPENAI_API_KEY;

const model = new ChatOpenAI({
  model: 'gpt-4o',
  temperature: 0,
  apiKey: openai_api_key,
});

// minimal schema for placeholder tool
const placeholder_schema = z.object({
  meal: z.string(),
});

// placeholder tool to avoid empty functions array error
const placeholder_tool = new DynamicTool({
  name: 'placeholder_tool',
  description: 'This is a placeholder tool.',
  func: async () => {
    return 'This is a placeholder response.';
  },
  schema: placeholder_schema,
});

const tools = [placeholder_tool];

// get the current time and day
const currentDateTime = new Date();
const currentTime = currentDateTime.toTimeString().split(' ')[0];
const currentDay = currentDateTime.toLocaleDateString('en-US', { weekday: 'long' });

// warmup prompt
const prompt = ChatPromptTemplate.fromMessages([
  ['system', `You are a helpful assistant for an app called Nom. Your role is to generate or modify meal plans for the user. By default, meal plans contain 3 meals a day for a week. When creating a meal plan, start it at the next upcoming meal based on the current time and day. The current time is ${currentTime} and the current day is ${currentDay}. Output the meal plan in the following JSON format: {{"days":[{{"day":1,"meals":{{"breakfast":"","lunch":"","dinner":""}}}}, ... ]}}`],
  ['user', '{input}'],
  new MessagesPlaceholder('agent_scratchpad'),
]);

// langchain agent tools
const model_with_functions = model.bind({
  functions: tools.map(tool => convertToOpenAIFunction(tool)),
});

// create langchain agent
const runnable_agent = RunnableSequence.from([
  {
    input: (i) => i.input,
    agent_scratchpad: (i) => formatToOpenAIFunctionMessages(i.steps),
  },
  prompt,
  model_with_functions,
  new OpenAIFunctionsAgentOutputParser(),
]);

const executor = AgentExecutor.fromAgentAndTools({
  agent: runnable_agent,
  tools,
});

/* 
 * function to call the agent
 * @param {string} input - the user input to be processed by the agent
 * @returns {Promise<Object>} - the final meal plan generated by the agent
 */
async function call_agent(input, retries = 3) {
  console.log(`Calling agent executor with query: ${input}`);
  let attempt = 0;
  while (attempt < retries) {
    try {
      const result = await executor.invoke({ input });
      console.log('Raw Output:', result);

      const meal_plan = await parse_and_verify_output(result.output);
      if (meal_plan) {
        console.log('Final Meal Plan:', meal_plan);
        return meal_plan;
      }
    } catch (error) {
      console.error(`Error on attempt ${attempt + 1}:`, error);
    }
    attempt++;
  }
  console.error('Failed to generate a valid meal plan after multiple attempts.');
  return null;
}

/* 
 * function to parse and verify the output
 * @param {string} output - the raw output from the agent
 * @returns {Promise<Object|null>} - the parsed and verified meal plan or null if an error occurs
 */
async function parse_and_verify_output(output) {
  try {
    // extract the JSON part of the response
    const json_match = output.match(/{[\s\S]*}/);
    if (!json_match) {
      throw new Error('No JSON found in the output');
    }
    const json_string = json_match[0];
    const meal_plan = JSON.parse(json_string);

    // extract the response without the JSON part
    const response = output.split(json_string)[0].trim() + output.split(json_string)[1].trim();

    return { meal_plan, response };
  } catch (error) {
    console.error('Error parsing or verifying the meal plan:', error);
    return null;
  }
}

// current example
const user_input = "I want to bake a creme brulee recipe one night, and I want at least one Italian recipe.";
call_agent(user_input).then(result => {
  console.log('Parsed and Verified Meal Plan:', result);
}).catch(error => {
  console.error('Error:', error);
});

// memory for stateful conversation
const MEMORY_KEY = 'chat_history';
const chat_history = [];

const memory_prompt = ChatPromptTemplate.fromMessages([
  ['system', 'You are a helpful assistant for an app called Nom. Your role is to generate or modify meal plans for the user. By default, meal plans contain 3 meals a day for a week. When creating a meal plan, start it at the next upcoming meal based on the time and day you receive the request.'],
  new MessagesPlaceholder(MEMORY_KEY),
  ['user', '{input}'],
  new MessagesPlaceholder('agent_scratchpad'),
]);

const agent_with_memory = RunnableSequence.from([
  {
    input: (i) => i.input,
    agent_scratchpad: (i) => formatToOpenAIFunctionMessages(i.steps),
    chat_history: (i) => i.chat_history,
  },
  memory_prompt,
  model_with_functions,
  new OpenAIFunctionsAgentOutputParser(),
]);

const executor_with_memory = AgentExecutor.fromAgentAndTools({
  agent: agent_with_memory,
  tools,
});

/* 
 * function to call the agent with memory
 * @param {string} input - the user input to be processed by the agent
 * @returns {Promise<string>} - the final output from the agent
 */
async function call_agent_with_memory(input) {
  console.log(`Calling agent executor with query: ${input}`);
  const result = await executor_with_memory.invoke({ input, chat_history });
  console.log(result);

  chat_history.push(new HumanMessage(input));
  chat_history.push(new AIMessage(result.output));

  return result.output;
}

// example code of how to do followup input
// const user_input_with_memory = "How many letters in the word educa?";
// call_agent_with_memory(user_input_with_memory).then(result => {
//   console.log('Final Result:', result);

//   const follow_up_input = "Is that a real English word?";
//   return call_agent_with_memory(follow_up_input);
// }).then(result => {
//   console.log('Follow-Up Result:', result);
// }).catch(error => {
//   console.error('Error:', error);
// });